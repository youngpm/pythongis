Open Source Python GIS Tools
10 February 2015
Tags: python gis

Patrick Young
Research Scientist, DigitalGlobe
patrick.young@digitalglobe.com

* DigitalGlobe

- Five Earth observing satellites providing foundational imagery that many GIS layers are built on top of
- We collect millions of square kilometers of high resolution (up to 0.25 m) imagery a day
- Our archive contains over a billion square kilometers of pixels!

.image images/fuji.jpg _ 600

* Python

- We've progressively been moving many of our R&D activities from commercial tools (MatLab, ENVI/IDL) to Python
- Enabled by the excellent open source GIS software packages written or wrapped by Python
- R&D further accelerated by the huge number of open source image processing algorithms (opencv, scikit-image, etc) and the scipy stack
- This has been a grass roots movement (not dictated from above!)

* GDAL and OGR

GDAL and OGR ([[http://gdal.org/][gdal.org]]) are foundational C++ libraries for manipulating geospatial raster and vector data, respectively

- SWIG bindings allow for easy reads and writes of raster data to and from numpy arrays
- The bindings have a C feel, but are very powerful
- It helps to be familiar with the C++ API as the docstrings can be lacking
- Behavior of the bindings can be _surprising_ [[http://trac.osgeo.org/gdal/wiki/PythonGotchas]]
- The Python GDAL/OGR Cookbook [[http://pcjericks.github.io/py-gdalogr-cookbook/]] is an excellent starting point

* GDAL Examples

Read an Image

We input from the osgeo package

.code code/gdal_read.py /START IMPORTS/,/END IMPORTS/

Reading into a numpy array is straightforward,

.code code/gdal_read.py /try:/,/processing/

but be sure to set the dataset to None when done!

* GDAL Examples

    In [1]: im
    Out[1]: 
    array([[[ 745,  701,  759, ..., 1109, 1046,  706],
            [ 769,  711,  774, ..., 1167, 1061,  795],
            [ 719,  719,  743, ..., 1232, 1185, 1059],
            ..., 
            [ 967,  990,  953, ...,  669,  666,  793],
            [1014,  969, 1011, ...,  637,  677,  709],
            [1046, 1072, 1059, ...,  603,  664,  680]],
        
           [[ 567,  512,  586, ...,  930,  851,  436],
            [ 597,  522,  601, ...,  971,  859,  539],
            [ 534,  531,  556, ..., 1052, 1015,  872],
            ..., 
            [1212, 1163, 1052, ...,  471,  434,  578],
            [ 966,  830,  830, ...,  520,  490,  503],
            [ 869,  822,  755, ...,  511,  493,  474]]], dtype=uint16)
    	
* GDAL Examples

Write an Image

A writable dataset can be both read from and written to

.code code/gdal_write.py /processing on im/,/ds_out = None/

Note that the dataset has to exist first before we open it...

* GDAL Examples

Create a Dataset

Often, you'll want to create a new dataset to write to rather than an existing one



A really useful driver is the "MEM" driver for when you need a temporary GDAL dataset but want to avoid real IO

  dvr = gdal.GetDriverByName("MEM")

* GDAL Examples

The underlying APIs used in most of the [[http://www.gdal.org/gdal_utilities.html][GDAL utilities]] can be accessed via the Python API 

For example, to rasterize a vector file, you could do this

.code code/gdal_rasterize_ex.py /ds_vector/,/options/

* What We are Rasterizing

.image images/roads_vector.png _ 800

* The Result

.image images/roads_rasterized.png _ 800

* OGR

GDAL handles raster data while OGR takes care of vector data.  In the previous example, I used an OGR dataset to rasterize from

.code code/gdal_rasterize_ex.py /ds_vector/,/GetLayer/

If you're a GDAL power user, you'll quickly find you'll be needing OGR!

* An OGR Example

I find reading, writing, and creating vector datasets to be especially clunky and error prone to do directly via those bindings.  

    from osgeo import ogr
    
    # Create ring
    ring = ogr.Geometry(ogr.wkbLinearRing)
    ring.AddPoint(1179091.1646903288, 712782.8838459781)
    ring.AddPoint(1161053.0218226474, 667456.2684348812)
    ring.AddPoint(1214704.933941905, 641092.8288590391)
    ring.AddPoint(1228580.428455506, 682719.3123998424)
    ring.AddPoint(1218405.0658121984, 721108.1805541387)
    ring.AddPoint(1179091.1646903288, 712782.8838459781)
    
    # Create polygon
    poly = ogr.Geometry(ogr.wkbPolygon)
    poly.AddGeometry(ring)
    
    print poly.ExportToWkt()

.caption From the [[http://pcjericks.github.io/py-gdalogr-cookbook/geometry.html#create-a-polygon][GDAL/OGR Cookbook]]

* A More Pythonic Way

GDAL and OGR are really powerful, but the bindings don't feel like idiomatic python. Fortunately for us, the open source community has come through with some excellent alternatives!

- Sean Gillies [[sgillies.net]] is the lead author of many of the sweet Python GIS packages

I've taken inspiration from a couple of talks 

- [[http://sgillies.github.io/foss4g-2014-fiona-rasterio/#/][Fiona and Rasterio]] by Sean Gillies
- [[https://github.com/pdxmele/python-geodata-bffs][Python + Geographic Data = BFFs]] by Mele Sax-Barnett

There are lots of cool examples in them, you should check them out!

* GeoJSON

[[http://geojson.org/][GeoJSON]] is a schema for JSON for representing GIS vector data (typically composed of a coordinate system and projection plus the actual geometries)

.code code/json_ex.json

* Fiona

[[http://toblerity.org/fiona/manual.html][Fiona]] is a Cython wrapper around a subset of the OGR bindings

- It handles reading and writing to some of the weird GIS formats (ESRI Shapefiles are ubiquitious)
- Talks in a GeoJSON like format

Very pythonic in its usage:
     
.code code/fiona_read.py

    Geometry 0 is of type LineString
    Geometry 1 is of type LineString
    Geometry 2 is of type LineString
    ...

* Fiona

Fiona fetches records as a GeoJSON like dictionary:

    In [6]: pprint(rec)
    {'geometry': {'coordinates': [(-122.67690464926368, 45.479812645666556),
                                  (-122.67693994280965, 45.47586557979783)],
                  'type': 'LineString'},
     'id': '8',
     'properties': OrderedDict([(u'id', None)]),
     'type': 'Feature'}

- This makes your life easy, simply pass the dict around to your own code

All the information on the coordinate system, projection, and shapefile schema are there (crs conforms to how the [[http://trac.osgeo.org/proj/][PROJ.4]] library handles it, check out [[https://github.com/jswhit/pyproj][pyproj]] for a nice wrapper of that library)

    In [9]: source.meta
    Out[9]:
    {'crs': {'init': u'epsg:4326'},
     'driver': u'ESRI Shapefile',
     'schema': {'geometry': 'LineString',
      'properties': OrderedDict([(u'id', 'int:10')])}}

* Fiona



